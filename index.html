<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Cor-Tech - v5 (Configurable)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap');
        :root {
            --primary-color: #2c3e50; --background-color: #ecf0f1; --light-color: #ffffff;
            --correct-color: #2ecc71; --incorrect-color: #e74c3c; --waiting-color: #f39c12;
            --validated-color: #2ecc71; --buzz-blue: #007bff; --buzz-orange: #fd7e14;
            --buzz-green: #28a745; --buzz-yellow: #ffc107; --buzz-red: #dc3545;
        }
        body { font-family: 'Poppins', sans-serif; background-color: var(--background-color); color: var(--primary-color); margin: 0; padding: 20px; text-align: center; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        .container { width: 90%; max-width: 900px; background: var(--light-color); padding: 30px; border-radius: 15px; box-shadow: 0 10px 20px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: var(--primary-color); }
        h1 { font-size: 2.5em; margin-bottom: 10px; }
        #setup-screen, #game-screen, #end-screen, #config-screen { display: none; }
        #setup-screen.active, #game-screen.active, #end-screen.active, #config-screen.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .button { background-color: var(--primary-color); color: var(--light-color); border: none; padding: 15px 30px; font-size: 1.2em; font-weight: bold; border-radius: 50px; cursor: pointer; margin-top: 20px; transition: background-color 0.3s, transform 0.2s; }
        .button:hover { background-color: #34495e; transform: translateY(-2px); }
        .button.secondary { background-color: #7f8c8d; }
        .button.secondary:hover { background-color: #95a5a6; }
        
        /* --- √âcran de Configuration --- */
        #config-container { display: flex; flex-direction: column; gap: 30px; }
        .config-section h3 { border-bottom: 2px solid var(--background-color); padding-bottom: 10px; }
        #buzzer-tester-area { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; min-height: 50px;}
        .tester-player { border: 1px solid #ddd; border-radius: 8px; padding: 10px; background: #fafafa; }
        .tester-player h4 { margin: 0 0 10px 0; }
        .tester-buttons { display: flex; flex-wrap: wrap; gap: 8px; }
        .tester-button { padding: 5px 10px; border-radius: 5px; background: #eee; font-size: 0.9em; transition: all 0.1s; border: 1px solid #ddd; }
        .tester-button.pressed { transform: scale(1.1); font-weight: bold; background-color: var(--buzz-yellow); border-color: var(--waiting-color); }
        #buzzer-mapper-area table { width: 100%; border-collapse: collapse; text-align: left; }
        #buzzer-mapper-area th, #buzzer-mapper-area td { padding: 12px; border-bottom: 1px solid #eee; }
        .map-button { font-size: 0.9em; padding: 5px 10px; cursor: pointer; border-radius: 5px; border: 1px solid #ccc; background: #f9f9f9; }
        .map-button.listening { background: var(--buzz-orange); color: white; border-color: var(--buzz-orange); animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(253, 126, 20, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(253, 126, 20, 0); } 100% { box-shadow: 0 0 0 0 rgba(253, 126, 20, 0); } }
        .color-label { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; vertical-align: middle; }
        #mapping-status { font-weight: bold; color: var(--buzz-orange); min-height: 20px; }

        /* --- √âcran de D√©marrage --- */
        .instructions { background: #f8f9fa; border-left: 4px solid var(--buzz-blue); padding: 1px 15px; text-align: left; margin: 15px 0; border-radius: 4px; }
        #buzzer-status { font-weight: bold; padding: 10px; border-radius: 5px; margin: 15px 0; transition: all 0.3s; }
        #buzzer-status.ok { background-color: #eaf6ec; color: var(--validated-color); }
        #buzzer-status.ko { background-color: #fbecec; color: var(--incorrect-color); }
        #player-names-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; text-align: left; margin-top: 10px; }
        .player-input-group label { font-weight: bold; margin-bottom: 5px; display: block; }
        .player-input-group input { width: 95%; padding: 8px; border: 2px solid #ddd; border-radius: 5px; }
        #question-input { width: 95%; height: 150px; margin-top: 10px; padding: 10px; border: 2px dashed #bdc3c7; border-radius: 5px; font-family: monospace; }

        /* --- Styles du Jeu et de Fin (inchang√©s) --- */
        #answers-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        .answer { background-color: var(--light-color); border: 4px solid; border-radius: 10px; padding: 20px; font-size: 1.2em; transition: all 0.2s; display: flex; align-items: center; justify-content: center; min-height: 60px; }
        #answer-0 { border-color: var(--buzz-blue); } #answer-1 { border-color: var(--buzz-orange); } #answer-2 { border-color: var(--buzz-green); } #answer-3 { border-color: var(--buzz-yellow); }
        .answer.correct { background-color: var(--correct-color); color: var(--light-color); border-color: var(--correct-color); transform: scale(1.05); }
        .answer.incorrect { background-color: var(--incorrect-color); color: var(--light-color); border-color: var(--incorrect-color); opacity: 0.7; }
        #timer-container { width: 100%; height: 10px; background-color: #bdc3c7; border-radius: 5px; margin-top: 20px; overflow: hidden; }
        #timer-bar { width: 100%; height: 100%; background-color: var(--buzz-blue); transition: width 0.1s linear; }
        #scores-container { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; font-weight: bold; font-size: 1.1em; text-align: left; }
        .player-status .status-icon { margin-left: 8px; font-size: 1.2em; }
        .player-status.waiting .status-icon { color: var(--waiting-color); }
        .player-status.validated .status-icon { color: var(--validated-color); }
        #final-ranking { list-style-type: none; padding: 0; }
        #final-ranking li { display: flex; justify-content: space-between; background-color: #ecf0f1; margin: 10px 0; padding: 15px; border-radius: 5px; font-size: 1.3em; }
        #final-ranking li:first-child { background-color: #f1c40f; font-weight: bold; }
    </style>
</head>
<body>

    <div class="container">
        <div id="setup-screen" class="active">
            <h1>üöÄ Quiz Cor-Tech üöÄ</h1>
            <div id="buzzer-status">D√©tection des buzzers...</div>
            <div class="instructions"><p><strong>R√®gle du jeu :</strong> Appuyez sur une couleur pour choisir, puis sur le <strong>gros bouton rouge</strong> pour valider !</p></div>
            <button class="button secondary" onclick="switchScreen('config-screen')">Tester & Configurer les Buzzers</button>
            <hr style="margin: 20px 0; border: 1px solid #eee;">
            <h3>Noms des Joueurs</h3>
            <div id="player-names-container">
                <div class="player-input-group"><label for="player-1-name">Joueur 1</label><input type="text" id="player-1-name" placeholder="Nom du joueur 1"></div>
                <div class="player-input-group"><label for="player-2-name">Joueur 2</label><input type="text" id="player-2-name" placeholder="Nom du joueur 2"></div>
                <div class="player-input-group"><label for="player-3-name">Joueur 3</label><input type="text" id="player-3-name" placeholder="Nom du joueur 3"></div>
                <div class="player-input-group"><label for="player-4-name">Joueur 4</label><input type="text" id="player-4-name" placeholder="Nom du joueur 4"></div>
            </div>
            <h3>Questions du Quiz</h3>
            <textarea id="question-input" placeholder="Collez vos questions ici..."></textarea>
            <button class="button" onclick="startGame()">Lancer le Tournoi !</button>
        </div>

        <div id="config-screen">
            <h2>Configuration des Buzzers</h2>
            <div id="config-container">
                <div class="config-section">
                    <h3>Moniteur d'Entr√©e (Testez vos buzzers ici)</h3>
                    <div id="buzzer-tester-area">
                        <p>Aucun buzzer d√©tect√©. Branchez-les ou assurez-vous que Steam est lanc√©...</p>
                    </div>
                </div>
                <div class="config-section">
                    <h3>Mappage des Boutons</h3>
                    <p>Cliquez sur "Assigner", puis appuyez sur le bouton physique du buzzer correspondant. La configuration est sauvegard√©e automatiquement.</p>
                    <p id="mapping-status"></p>
                    <div id="buzzer-mapper-area"></div>
                </div>
            </div>
            <button class="button" onclick="saveConfigAndReturn()">Sauvegarder et Retourner</button>
        </div>

        <div id="game-screen">
             <div id="question-container"><p id="question-number"></p><h2 id="question-text"></h2></div>
             <div id="answers-container">
                 <div class="answer" id="answer-0"></div><div class="answer" id="answer-1"></div>
                 <div class="answer" id="answer-2"></div><div class="answer" id="answer-3"></div>
             </div>
             <div id="timer-container"><div id="timer-bar"></div></div>
             <div id="scores-container"></div>
        </div>
        
        <div id="end-screen">
             <h1>Partie Termin√©e !</h1><h2>Classement Final</h2>
             <ul id="final-ranking"></ul>
             <button class="button" onclick="restartGame()">Rejouer</button>
             <button class="button" onclick="location.reload()">Nouveau Quiz</button>
        </div>
    </div>

    <script>
        // --- VARIABLES GLOBALES ---
        let questions = []; let currentQuestionIndex = 0; let scores = {}; let playerNames = [];
        let playerAnswers = {}; let timerInterval; let isRevealing = false;
        const TIME_PER_QUESTION = 20; const POINTS_PER_ANSWER = 100;
        
        // --- GESTION DE LA CONFIGURATION ---
        let buzzConfig = {}; // { '0': { blue: 9, orange: 6, green: 7, yellow: 8, red: 5 }, '1': ... }
        let isMapping = false;
        let mappingTarget = { player: null, action: null }; // Ex: { player: '0', action: 'blue' }
        const ACTIONS = [ // Actions et couleurs associ√©es pour le configurateur
            { id: 'blue', label: 'R√©ponse Bleue', color: 'var(--buzz-blue)'},
            { id: 'orange', label: 'R√©ponse Orange', color: 'var(--buzz-orange)'},
            { id: 'green', label: 'R√©ponse Verte', color: 'var(--buzz-green)'},
            { id: 'yellow', label: 'R√©ponse Jaune', color: 'var(--buzz-yellow)'},
            { id: 'red', label: 'Validation (Rouge)', color: 'var(--buzz-red)'}
        ];

        // --- √âL√âMENTS DU DOM ---
        const allScreens = document.querySelectorAll('.container > div');
        const buzzerStatusEl = document.getElementById('buzzer-status');
        const testerArea = document.getElementById('buzzer-tester-area');
        const mapperArea = document.getElementById('buzzer-mapper-area');
        const mappingStatusEl = document.getElementById('mapping-status');

        // --- LOGIQUE DE NAVIGATION ET DE D√âMARRAGE ---
        function switchScreen(screenId) {
            allScreens.forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        window.onload = function() {
            loadConfig();
            updateBuzzerStatus();
            // Lancer la boucle de d√©tection permanente
            setInterval(gamepadLoop, 100); 
        };

        // --- GESTION DE LA CONFIGURATION (SAUVEGARDE, CHARGEMENT, UI) ---
        function saveConfig() {
            localStorage.setItem('buzzConfig', JSON.stringify(buzzConfig));
        }

        function loadConfig() {
            const savedConfig = localStorage.getItem('buzzConfig');
            if (savedConfig) {
                buzzConfig = JSON.parse(savedConfig);
            } else {
                // Configuration par d√©faut (bas√©e sur la derni√®re discussion)
                buzzConfig = { 
                    '0': { blue: 9, orange: 6, green: 7, yellow: 8, red: 5 }
                };
            }
        }

        function saveConfigAndReturn(){
            saveConfig();
            alert("Configuration sauvegard√©e !");
            switchScreen('setup-screen');
        }

        function startMapping(playerId, actionId) {
            isMapping = true;
            mappingTarget = { player: playerId, action: actionId };
            document.querySelectorAll('.map-button').forEach(b => b.classList.remove('listening'));
            const buttonEl = document.getElementById(`map-btn-${playerId}-${actionId}`);
            buttonEl.classList.add('listening');
            buttonEl.textContent = '...';
            mappingStatusEl.textContent = `Appuyez sur le bouton d√©sir√© pour le Joueur ${parseInt(playerId) + 1}...`;
        }

        function assignButton(buttonIndex) {
            if (!isMapping) return;
            const { player, action } = mappingTarget;

            // Initialiser l'objet pour ce joueur si n√©cessaire
            if (!buzzConfig[player]) buzzConfig[player] = {};
            
            // V√©rifier si ce bouton est d√©j√† assign√© √† une autre action pour CE joueur
            for(const act in buzzConfig[player]){
                if(buzzConfig[player][act] === buttonIndex){
                    buzzConfig[player][act] = null; // D√©sassigner l'ancienne action
                }
            }

            buzzConfig[player][action] = buttonIndex;
            
            isMapping = false;
            mappingStatusEl.textContent = '';
            populateMapper(); // Rafra√Æchir l'affichage du mappage
        }

        function populateTesterAndMapper(gamepads) {
            if (!document.getElementById('config-screen').classList.contains('active')) return;
            
            if (gamepads.length === 0) {
                testerArea.innerHTML = "<p>Aucun buzzer d√©tect√©. Branchez-les ou assurez-vous que Steam est lanc√©...</p>";
                mapperArea.innerHTML = "";
                return;
            }

            // Moniteur d'entr√©e (Testeur)
            let testerHTML = '';
            gamepads.forEach(gp => {
                testerHTML += `
                    <div class="tester-player" id="tester-player-${gp.index}">
                        <h4>Joueur ${gp.index + 1}</h4>
                        <div class="tester-buttons">
                            ${gp.buttons.map((b, i) => `<div class="tester-button" id="tester-btn-${gp.index}-${i}">B${i}</div>`).join('')}
                        </div>
                    </div>
                `;
            });
            testerArea.innerHTML = testerHTML;

            // Mappage des boutons
            let mapperHTML = `
                <table>
                    <tr>
                        <th>Action du Jeu</th>
                        ${gamepads.map(gp => `<th>Joueur ${gp.index + 1}</th>`).join('')}
                    </tr>
            `;
            ACTIONS.forEach(action => {
                mapperHTML += `<tr><td><span class="color-label" style="background-color:${action.color};"></span>${action.label}</td>`;
                gamepads.forEach(gp => {
                    const assignedButton = (buzzConfig[gp.index] && buzzConfig[gp.index][action.id] !== null) ? `Bouton ${buzzConfig[gp.index][action.id]}` : 'Non assign√©';
                    mapperHTML += `
                        <td>
                            <button class="map-button" id="map-btn-${gp.index}-${action.id}" onclick="startMapping('${gp.index}', '${action.id}')">
                                ${assignedButton}
                            </button>
                        </td>
                    `;
                });
                mapperHTML += `</tr>`;
            });
            mapperHTML += `</table>`;
            mapperArea.innerHTML = mapperHTML;
        }

        // --- BOUCLE PRINCIPALE (POUR D√âTECTION ET JEU) ---
        let lastConnectedGamepads = 0;
        function gamepadLoop() {
            const rawGamepads = navigator.getGamepads();
            if (!rawGamepads) return;

            const gamepads = Array.from(rawGamepads).filter(gp => gp && gp.buttons.length > 0);
            
            // Si le nombre de manettes change, on met √† jour le statut et le configurateur
            if(gamepads.length !== lastConnectedGamepads){
                lastConnectedGamepads = gamepads.length;
                updateBuzzerStatus(gamepads.length);
                populateTesterAndMapper(gamepads);
            }

            // Gestion des inputs
            gamepads.forEach(gp => {
                gp.buttons.forEach((button, buttonIndex) => {
                    // Si on est sur l'√©cran de config
                    if (document.getElementById('config-screen').classList.contains('active')) {
                        const btnEl = document.getElementById(`tester-btn-${gp.index}-${buttonIndex}`);
                        if (button.pressed) {
                            if(btnEl) btnEl.classList.add('pressed');
                            if (isMapping) assignButton(buttonIndex);
                        } else {
                            if(btnEl) btnEl.classList.remove('pressed');
                        }
                    }
                    
                    // Si on est sur l'√©cran de jeu (logique existante)
                    if(document.getElementById('game-screen').classList.contains('active')){
                        const playerButtonPressed = game.playerButtonPressed; // (simulation)
                        if (button.pressed && !playerButtonPressed[gp.index]?.[buttonIndex]) {
                            handleGameInput(gp.index, buttonIndex);
                            if(!playerButtonPressed[gp.index]) playerButtonPressed[gp.index] = {};
                            playerButtonPressed[gp.index][buttonIndex] = true;
                        } else if (!button.pressed) {
                            if(playerButtonPressed[gp.index]) playerButtonPressed[gp.index][buttonIndex] = false;
                        }
                    }
                });
            });
        }
        
        // --- LOGIQUE DE JEU (Adapt√©e pour utiliser buzzConfig) ---
        const game = { playerButtonPressed: {} }; // Namespace pour les variables de jeu
        
        function updateBuzzerStatus(count = -1) {
            const num = count === -1 ? Array.from(navigator.getGamepads()).filter(gp => gp).length : count;
            if (num > 0) {
                buzzerStatusEl.textContent = `Statut : ${num} buzzer(s) d√©tect√©(s) ‚úÖ`;
                buzzerStatusEl.className = 'ok';
            } else {
                buzzerStatusEl.textContent = `Statut : Aucun buzzer d√©tect√© ‚ùå`;
                buzzerStatusEl.className = 'ko';
            }
        }

        function handleGameInput(playerId, buttonIndex) {
            const playerConfig = buzzConfig[playerId];
            if (!playerConfig) return;

            // Chercher √† quelle action correspond le bouton press√©
            for (const actionId in playerConfig) {
                if (playerConfig[actionId] === buttonIndex) {
                    const action = ACTIONS.find(a => a.id === actionId);
                    if (action.id === 'red') {
                        handleValidation(playerId);
                    } else {
                        // 'blue' -> 0, 'orange' -> 1, etc.
                        const answerIndex = ACTIONS.findIndex(a => a.id === actionId);
                        handleAnswer(playerId, answerIndex);
                    }
                    return; // Sortir d√®s qu'une action est trouv√©e
                }
            }
        }
        
        // Le reste des fonctions de jeu (startGame, handleAnswer, etc.) est identique au code pr√©c√©dent
        // Il suffit de les copier ici. Pour la compacit√©, je remets seulement celles qui sont essentielles.
        function startGame() {
            parseQuestions(); if(questions.length === 0){ alert("Questions mal format√©es."); return; }
            playerNames = [];
            for (let i = 0; i < 4; i++) {
                const nameInput = document.getElementById(`player-${i + 1}-name`);
                playerNames[i] = nameInput.value.trim() || `Joueur ${i + 1}`;
            }
            scores = {}; currentQuestionIndex = 0; game.playerButtonPressed = {};
            switchScreen('game-screen');
            showQuestion();
        }
        function handleAnswer(playerId, answerIndex) {
            if (isRevealing || (playerAnswers[playerId] && playerAnswers[playerId].validated)) return;
            playerAnswers[playerId] = { answer: answerIndex, validated: false };
            updatePlayersStatusDisplay();
        }
        function handleValidation(playerId) {
            if (isRevealing || !playerAnswers[playerId] || playerAnswers[playerId].validated) return;
            playerAnswers[playerId].validated = true;
            updatePlayersStatusDisplay(); checkAllValidated();
        }
        function checkAllValidated() {
            const answeredPlayers = Object.keys(playerAnswers);
            if (answeredPlayers.length === 0 || isRevealing) return;
            const allValidated = answeredPlayers.every(id => playerAnswers[id].validated);
            if (allValidated) { revealAnswer(); }
        }
        function revealAnswer() {
            isRevealing = true; clearInterval(timerInterval);
            const q = questions[currentQuestionIndex];
            for (const playerId in playerAnswers) {
                if (playerAnswers[playerId].answer === q.correct) { scores[playerId] = (scores[playerId] || 0) + POINTS_PER_ANSWER; }
            }
            for (let i = 0; i < 4; i++) {
                const answerEl = document.getElementById(`answer-${i}`);
                if (i === q.correct) { answerEl.classList.add('correct'); } else { answerEl.classList.add('incorrect'); }
            }
            updatePlayersStatusDisplay(); setTimeout(nextQuestion, 4000);
        }
        function nextQuestion() {
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) { showQuestion(); } else { switchScreen('end-screen'); endGame(); }
        }
        function showQuestion() {
            isRevealing = false;
            game.playerButtonPressed = {};
            gameScreen.style.opacity = 0;
            setTimeout(() => {
                resetQuestionState();
                const q = questions[currentQuestionIndex];
                document.getElementById('question-number').innerText = `Question ${currentQuestionIndex + 1} / ${questions.length}`;
                document.getElementById('question-text').innerText = q.question;
                q.answers.forEach((answer, index) => { document.getElementById(`answer-${index}`).innerText = answer; });
                startTimer(); gameScreen.style.opacity = 1;
            }, 500);
        }
        function startTimer() {
            let timeLeft = TIME_PER_QUESTION;
            const timerBar = document.getElementById('timer-bar');
            timerBar.style.transition = 'none'; timerBar.style.width = '100%';
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft -= 0.1;
                timerBar.style.width = `${(timeLeft / TIME_PER_QUESTION) * 100}%`;
                if (timeLeft <= 0) { clearInterval(timerInterval); if (!isRevealing) revealAnswer(); }
            }, 100);
        }
        function resetQuestionState() {
            playerAnswers = {}; isRevealing = false;
            document.getElementById('timer-bar').style.width = '100%';
            for (let i = 0; i < 4; i++) { document.getElementById(`answer-${i}`).className = 'answer'; }
            updatePlayersStatusDisplay();
        }
        function updatePlayersStatusDisplay() {
            const scoresContainer = document.getElementById('scores-container');
            scoresContainer.innerHTML = '';
            const gamepads = Array.from(navigator.getGamepads()).filter(gp => gp);
            let playerIds = new Set(Object.keys(scores));
            gamepads.forEach(gp => playerIds.add(String(gp.index)));
            const sortedPlayerIds = Array.from(playerIds).sort((a,b) => a - b);
            sortedPlayerIds.forEach(id => {
                 const playerEl = document.createElement('div');
                 playerEl.className = 'player-status';
                 const playerName = playerNames[id] || `Joueur ${parseInt(id) + 1}`;
                 const playerScore = scores[id] || 0;
                 let statusIcon = '';
                 if (!isRevealing && playerAnswers[id]) {
                     if(playerAnswers[id].validated) {
                         playerEl.classList.add('validated'); statusIcon = '<span class="status-icon">‚úîÔ∏è</span>';
                     } else {
                         playerEl.classList.add('waiting'); statusIcon = '<span class="status-icon">üí¨</span>';
                     }
                 }
                 playerEl.innerHTML = `<span>${playerName}: ${playerScore}</span>${statusIcon}`;
                 scoresContainer.appendChild(playerEl);
            });
        }
        function endGame() {
            const finalRanking = document.getElementById('final-ranking');
            finalRanking.innerHTML = '';
            const sortedScores = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            if (sortedScores.length === 0) { finalRanking.innerHTML = "<li>Aucun score n'a √©t√© enregistr√©.</li>"; return; }
            sortedScores.forEach(([playerId, score], index) => {
                const li = document.createElement('li');
                const trophy = index === 0 ? 'üèÜ' : (index === 1 ? 'ü•à' : (index === 2 ? 'ü•â' : ''));
                const playerName = playerNames[playerId] || `Joueur ${parseInt(playerId) + 1}`;
                li.innerHTML = `<span>${trophy} ${playerName}</span> <strong>${score} points</strong>`;
                finalRanking.appendChild(li);
            });
        }
        function restartGame() {
            scores = {}; currentQuestionIndex = 0; game.playerButtonPressed = {};
            switchScreen('game-screen');
            showQuestion();
        }
        function parseQuestions() {
            const input = document.getElementById('question-input').value.trim();
            if (!input) return;
            const blocks = input.split('\n\n');
            questions = blocks.map(block => {
                const lines = block.split('\n').filter(line => line.trim() !== '');
                if (lines.length < 5) return null;
                const questionText = lines[0];
                const answers = lines.slice(1, 5);
                const correctAnswerIndex = answers.findIndex(answer => answer.endsWith('*'));
                if (correctAnswerIndex === -1) return null;
                const cleanedAnswers = answers.map(answer => answer.replace('*', '').trim());
                return { question: questionText, answers: cleanedAnswers, correct: correctAnswerIndex };
            }).filter(q => q !== null);
        }
    </script>
</body>
</html>
