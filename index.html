<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Cor-Tech - v6 (Auto-Calibration)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap');
        :root {
            --primary-color: #2c3e50; --background-color: #ecf0f1; --light-color: #ffffff;
            --correct-color: #2ecc71; --incorrect-color: #e74c3c; --waiting-color: #f39c12;
            --validated-color: #2ecc71; --buzz-blue: #007bff; --buzz-orange: #fd7e14;
            --buzz-green: #28a745; --buzz-yellow: #ffc107; --buzz-red: #dc3545;
        }
        body { font-family: 'Poppins', sans-serif; background-color: var(--background-color); color: var(--primary-color); margin: 0; padding: 20px; text-align: center; display: flex; justify-content: center; align-items: center; min-height: 100vh; }
        .container { width: 90%; max-width: 900px; background: var(--light-color); padding: 30px; border-radius: 15px; box-shadow: 0 10px 20px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: var(--primary-color); }
        h1 { font-size: 2.5em; margin-bottom: 10px; }
        #setup-screen, #game-screen, #end-screen, #config-screen { display: none; }
        #setup-screen.active, #game-screen.active, #end-screen.active, #config-screen.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .button { background-color: var(--primary-color); color: var(--light-color); border: none; padding: 15px 30px; font-size: 1.2em; font-weight: bold; border-radius: 50px; cursor: pointer; margin-top: 20px; transition: background-color 0.3s, transform 0.2s; }
        .button:hover { background-color: #34495e; transform: translateY(-2px); }
        .button.secondary { background-color: #7f8c8d; }
        .button.secondary:hover { background-color: #95a5a6; }
        hr { border: 0; height: 1px; background: #eee; margin: 20px 0; }
        
        /* --- Écran de Configuration (Assistant) --- */
        #config-screen { padding: 40px; }
        #wizard-box { border: 3px dashed var(--buzz-blue); padding: 30px; border-radius: 15px; }
        #wizard-instruction { font-size: 2em; font-weight: bold; min-height: 100px; display: flex; align-items: center; justify-content: center; }
        .instruction-color { padding: 5px 10px; border-radius: 5px; color: white; }
        .progress-bar-container { width: 100%; background: #eee; border-radius: 5px; height: 10px; margin-top: 20px; }
        #wizard-progress-bar { width: 0%; height: 100%; background: var(--validated-color); border-radius: 5px; transition: width 0.3s; }

        /* --- Écran de Démarrage --- */
        #buzzer-status { font-weight: bold; padding: 10px; border-radius: 5px; margin: 15px 0; transition: all 0.3s; }
        #buzzer-status.ok { background-color: #eaf6ec; color: var(--validated-color); }
        #buzzer-status.ko { background-color: #fbecec; color: var(--incorrect-color); }
        #player-names-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; text-align: left; margin-top: 10px; }
        .player-input-group label { font-weight: bold; margin-bottom: 5px; display: block; }
        .player-input-group input { width: 95%; padding: 8px; border: 2px solid #ddd; border-radius: 5px; }
        #question-input { width: 95%; height: 150px; margin-top: 10px; padding: 10px; border: 2px dashed #bdc3c7; border-radius: 5px; font-family: monospace; }

        /* --- Styles du Jeu et de Fin (inchangés) --- */
        #answers-container { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        .answer { background-color: var(--light-color); border: 4px solid; border-radius: 10px; padding: 20px; font-size: 1.2em; transition: all 0.2s; display: flex; align-items: center; justify-content: center; min-height: 60px; }
        #answer-0 { border-color: var(--buzz-blue); } #answer-1 { border-color: var(--buzz-orange); } #answer-2 { border-color: var(--buzz-green); } #answer-3 { border-color: var(--buzz-yellow); }
        .answer.correct { background-color: var(--correct-color); color: var(--light-color); border-color: var(--correct-color); transform: scale(1.05); }
        .answer.incorrect { background-color: var(--incorrect-color); color: var(--light-color); border-color: var(--incorrect-color); opacity: 0.7; }
        #timer-container { width: 100%; height: 10px; background-color: #bdc3c7; border-radius: 5px; margin-top: 20px; overflow: hidden; }
        #timer-bar { width: 100%; height: 100%; background-color: var(--buzz-blue); transition: width 0.1s linear; }
        #scores-container { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; font-weight: bold; font-size: 1.1em; text-align: left; }
        .player-status .status-icon { margin-left: 8px; font-size: 1.2em; }
        .player-status.waiting .status-icon { color: var(--waiting-color); }
        .player-status.validated .status-icon { color: var(--validated-color); }
        #final-ranking { list-style-type: none; padding: 0; }
        #final-ranking li { display: flex; justify-content: space-between; background-color: #ecf0f1; margin: 10px 0; padding: 15px; border-radius: 5px; font-size: 1.3em; }
        #final-ranking li:first-child { background-color: #f1c40f; font-weight: bold; }
    </style>
</head>
<body>

    <div class="container">
        <div id="setup-screen" class="active">
            <h1>🚀 Quiz Cor-Tech 🚀</h1>
            <div id="buzzer-status">Détection des buzzers...</div>
            <button class="button secondary" onclick="startConfigurationWizard()">Re-Calibrer les Buzzers</button>
            <hr>
            <h3>Noms des Joueurs</h3>
            <div id="player-names-container">
                <div class="player-input-group"><label for="player-1-name">Joueur 1</label><input type="text" id="player-1-name" placeholder="Nom du joueur 1"></div>
                <div class="player-input-group"><label for="player-2-name">Joueur 2</label><input type="text" id="player-2-name" placeholder="Nom du joueur 2"></div>
                <div class="player-input-group"><label for="player-3-name">Joueur 3</label><input type="text" id="player-3-name" placeholder="Nom du joueur 3"></div>
                <div class="player-input-group"><label for="player-4-name">Joueur 4</label><input type="text" id="player-4-name" placeholder="Nom du joueur 4"></div>
            </div>
            <h3>Questions du Quiz</h3>
            <textarea id="question-input" placeholder="Collez vos questions ici..."></textarea>
            <button class="button" onclick="startGame()">Lancer le Tournoi !</button>
        </div>

        <div id="config-screen">
            <h2>Assistant de Calibration des Buzzers</h2>
            <p>Suivez les instructions pour configurer vos buzzers. Vous n'aurez à le faire qu'une seule fois.</p>
            <div id="wizard-box">
                <div id="wizard-instruction">Préparation...</div>
                <div class="progress-bar-container">
                    <div id="wizard-progress-bar"></div>
                </div>
            </div>
        </div>

        <div id="game-screen">
             <div id="question-container"><p id="question-number"></p><h2 id="question-text"></h2></div>
             <div id="answers-container">
                 <div class="answer" id="answer-0"></div><div class="answer" id="answer-1"></div>
                 <div class="answer" id="answer-2"></div><div class="answer" id="answer-3"></div>
             </div>
             <div id="timer-container"><div id="timer-bar"></div></div>
             <div id="scores-container"></div>
        </div>
        
        <div id="end-screen">
             <h1>Partie Terminée !</h1><h2>Classement Final</h2>
             <ul id="final-ranking"></ul>
             <button class="button" onclick="restartGame()">Rejouer</button>
             <button class="button" onclick="location.reload()">Nouveau Quiz</button>
        </div>
    </div>

    <script>
        // --- VARIABLES GLOBALES ---
        let questions = []; let currentQuestionIndex = 0; let scores = {}; let playerNames = [];
        let playerAnswers = {}; let timerInterval; let isRevealing = false;
        const TIME_PER_QUESTION = 20; const POINTS_PER_ANSWER = 100;
        let buzzConfig = {}; // Structure: { '0': { blue: 9, orange: 6, ... }, '1': ... }
        let connectedGamepads = [];
        
        const ACTIONS = [
            { id: 'blue', label: 'BLEU', color: 'var(--buzz-blue)'},
            { id: 'orange', label: 'ORANGE', color: 'var(--buzz-orange)'},
            { id: 'green', label: 'VERT', color: 'var(--buzz-green)'},
            { id: 'yellow', label: 'JAUNE', color: 'var(--buzz-yellow)'},
            { id: 'red', label: 'ROUGE (Validation)', color: 'var(--buzz-red)'}
        ];

        // --- ÉLÉMENTS DU DOM ---
        const allScreens = document.querySelectorAll('.container > div');
        const buzzerStatusEl = document.getElementById('buzzer-status');
        const wizardInstructionEl = document.getElementById('wizard-instruction');
        const wizardProgressBar = document.getElementById('wizard-progress-bar');
        
        // --- LOGIQUE DE DÉMARRAGE ET NAVIGATION ---
        function switchScreen(screenId) {
            allScreens.forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
        }

        window.onload = function() {
            loadConfig();
            setInterval(gamepadLoop, 100); 
        };

        // --- GESTION DE LA CONFIGURATION (ASSISTANT) ---
        let wizardState = { active: false, playerIndex: 0, actionIndex: 0 };

        function saveConfig() {
            localStorage.setItem('buzzConfig', JSON.stringify(buzzConfig));
        }

        function loadConfig() {
            const savedConfig = localStorage.getItem('buzzConfig');
            if (savedConfig) {
                buzzConfig = JSON.parse(savedConfig);
            }
        }
        
        function isConfigValid() {
            if (Object.keys(buzzConfig).length === 0) return false;
            // Vérifie si tous les joueurs connectés ont une configuration complète
            return connectedGamepads.every(gp => {
                const config = buzzConfig[gp.index];
                return config && ACTIONS.every(action => typeof config[action.id] === 'number');
            });
        }

        function startConfigurationWizard() {
            if (connectedGamepads.length === 0) {
                alert("Aucun buzzer n'est branché ! Veuillez les connecter avant de lancer la calibration.");
                return;
            }
            buzzConfig = {}; // Réinitialise la config
            wizardState = { active: true, playerIndex: 0, actionIndex: 0 };
            switchScreen('config-screen');
            askNextButtonPress();
        }

        function askNextButtonPress() {
            if (!wizardState.active) return;
            
            const player = connectedGamepads[wizardState.playerIndex];
            const action = ACTIONS[wizardState.actionIndex];

            wizardInstructionEl.innerHTML = `
                Appuyez sur le bouton <span class="instruction-color" style="background-color:${action.color};">${action.label}</span> du Joueur ${player.index + 1}
            `;
            
            const totalSteps = connectedGamepads.length * ACTIONS.length;
            const currentStep = wizardState.playerIndex * ACTIONS.length + wizardState.actionIndex;
            wizardProgressBar.style.width = `${(currentStep / totalSteps) * 100}%`;
        }

        function onWizardButtonPress(playerIndex, buttonIndex) {
            if (!wizardState.active || playerIndex !== connectedGamepads[wizardState.playerIndex].index) return;
            
            // Évite d'assigner un bouton déjà utilisé pour ce joueur
            const currentConfig = buzzConfig[playerIndex] || {};
            for (const key in currentConfig) {
                if (currentConfig[key] === buttonIndex) {
                    alert(`Ce bouton est déjà assigné pour ce joueur. Veuillez en choisir un autre.`);
                    return;
                }
            }

            if (!buzzConfig[playerIndex]) buzzConfig[playerIndex] = {};
            const actionId = ACTIONS[wizardState.actionIndex].id;
            buzzConfig[playerIndex][actionId] = buttonIndex;

            // Passer à l'étape suivante
            wizardState.actionIndex++;
            if (wizardState.actionIndex >= ACTIONS.length) {
                wizardState.actionIndex = 0;
                wizardState.playerIndex++;
            }

            if (wizardState.playerIndex >= connectedGamepads.length) {
                // Fin de la configuration
                wizardState.active = false;
                wizardProgressBar.style.width = '100%';
                wizardInstructionEl.textContent = 'Configuration terminée !';
                saveConfig();
                setTimeout(() => {
                    updateBuzzerStatus();
                    switchScreen('setup-screen');
                }, 1500);
            } else {
                askNextButtonPress();
            }
        }

        // --- BOUCLE PRINCIPALE (POUR DÉTECTION ET JEU) ---
        const gamepadState = {}; // Pour ne détecter qu'une seule pression
        function gamepadLoop() {
            const rawGamepads = navigator.getGamepads();
            if (!rawGamepads) return;
            const newlyConnected = Array.from(rawGamepads).filter(gp => gp && gp.buttons.length > 0);
            
            if (newlyConnected.length !== connectedGamepads.length) {
                connectedGamepads = newlyConnected;
                updateBuzzerStatus();
            }

            connectedGamepads.forEach(gp => {
                if (!gamepadState[gp.index]) gamepadState[gp.index] = { buttons: [] };
                
                gp.buttons.forEach((button, buttonIndex) => {
                    const wasPressed = gamepadState[gp.index].buttons[buttonIndex];
                    if (button.pressed && !wasPressed) {
                        // LE BOUTON VIENT D'ÊTRE PRESSÉ
                        if (wizardState.active) {
                            onWizardButtonPress(gp.index, buttonIndex);
                        } else if (document.getElementById('game-screen').classList.contains('active')) {
                            handleGameInput(gp.index, buttonIndex);
                        }
                    }
                    gamepadState[gp.index].buttons[buttonIndex] = button.pressed;
                });
            });
        }
        
        // --- LOGIQUE DE JEU ---
        function updateBuzzerStatus() {
            if (connectedGamepads.length > 0) {
                if (isConfigValid()) {
                    buzzerStatusEl.textContent = `Statut : ${connectedGamepads.length} buzzer(s) détecté(s) et calibré(s) ✅`;
                    buzzerStatusEl.className = 'ok';
                } else {
                    buzzerStatusEl.textContent = `Statut : ${connectedGamepads.length} buzzer(s) détecté(s) mais non calibré(s) ⚠️`;
                    buzzerStatusEl.className = 'ko';
                }
            } else {
                buzzerStatusEl.textContent = `Statut : Aucun buzzer détecté ❌`;
                buzzerStatusEl.className = 'ko';
            }
        }

        function startGame() {
            if (!isConfigValid()) {
                startConfigurationWizard();
                return;
            }
            parseQuestions(); if(questions.length === 0){ alert("Questions mal formatées."); return; }
            playerNames = [];
            for (let i = 0; i < 4; i++) {
                const nameInput = document.getElementById(`player-${i + 1}-name`);
                playerNames[i] = nameInput.value.trim() || `Joueur ${i + 1}`;
            }
            scores = {}; currentQuestionIndex = 0;
            switchScreen('game-screen'); showQuestion();
        }

        function handleGameInput(playerId, buttonIndex) {
            const playerConfig = buzzConfig[playerId];
            if (!playerConfig || isRevealing) return;

            for (const actionId in playerConfig) {
                if (playerConfig[actionId] === buttonIndex) {
                    if (actionId === 'red') {
                        handleValidation(playerId);
                    } else {
                        const answerIndex = ACTIONS.findIndex(a => a.id === actionId);
                        if(answerIndex !== -1 && answerIndex < 4) handleAnswer(playerId, answerIndex);
                    }
                    return;
                }
            }
        }
        
        // Le reste des fonctions de jeu est identique (copié pour être complet)
        function handleAnswer(playerId, answerIndex) {
            if (playerAnswers[playerId] && playerAnswers[playerId].validated) return;
            playerAnswers[playerId] = { answer: answerIndex, validated: false };
            updatePlayersStatusDisplay();
        }
        function handleValidation(playerId) {
            if (!playerAnswers[playerId] || playerAnswers[playerId].validated) return;
            playerAnswers[playerId].validated = true;
            updatePlayersStatusDisplay(); checkAllValidated();
        }
        function checkAllValidated() {
            const answeredPlayers = connectedGamepads.map(gp => gp.index).filter(id => playerAnswers[id]);
            if (answeredPlayers.length === 0 || isRevealing) return;
            const allValidated = answeredPlayers.every(id => playerAnswers[id].validated);
            if (allValidated) { revealAnswer(); }
        }
        function revealAnswer() {
            isRevealing = true; clearInterval(timerInterval);
            const q = questions[currentQuestionIndex];
            for (const playerId in playerAnswers) {
                if (playerAnswers[playerId].answer === q.correct) { scores[playerId] = (scores[playerId] || 0) + POINTS_PER_ANSWER; }
            }
            for (let i = 0; i < 4; i++) {
                const answerEl = document.getElementById(`answer-${i}`);
                if (i === q.correct) { answerEl.classList.add('correct'); } else { answerEl.classList.add('incorrect'); }
            }
            updatePlayersStatusDisplay(); setTimeout(nextQuestion, 4000);
        }
        function nextQuestion() {
            currentQuestionIndex++;
            if (currentQuestionIndex < questions.length) { showQuestion(); } else { switchScreen('end-screen'); endGame(); }
        }
        function showQuestion() {
            isRevealing = false;
            gamepadState = {};
            playerAnswers = {};
            gameScreen.style.opacity = 0;
            setTimeout(() => {
                resetQuestionState();
                const q = questions[currentQuestionIndex];
                document.getElementById('question-number').innerText = `Question ${currentQuestionIndex + 1} / ${questions.length}`;
                document.getElementById('question-text').innerText = q.question;
                q.answers.forEach((answer, index) => { document.getElementById(`answer-${index}`).innerText = answer; });
                startTimer(); gameScreen.style.opacity = 1;
            }, 500);
        }
        function startTimer() {
            let timeLeft = TIME_PER_QUESTION;
            const timerBar = document.getElementById('timer-bar');
            timerBar.style.transition = 'none'; timerBar.style.width = '100%';
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft -= 0.1;
                timerBar.style.width = `${(timeLeft / TIME_PER_QUESTION) * 100}%`;
                if (timeLeft <= 0) { clearInterval(timerInterval); if (!isRevealing) revealAnswer(); }
            }, 100);
        }
        function resetQuestionState() {
            document.getElementById('timer-bar').style.width = '100%';
            for (let i = 0; i < 4; i++) { document.getElementById(`answer-${i}`).className = 'answer'; }
            updatePlayersStatusDisplay();
        }
        function updatePlayersStatusDisplay() {
            const scoresContainer = document.getElementById('scores-container');
            scoresContainer.innerHTML = '';
            const playerIds = connectedGamepads.map(gp => gp.index);
            playerIds.forEach(id => {
                 const playerEl = document.createElement('div');
                 playerEl.className = 'player-status';
                 const playerName = playerNames[id] || `Joueur ${parseInt(id) + 1}`;
                 const playerScore = scores[id] || 0;
                 let statusIcon = '';
                 if (!isRevealing && playerAnswers[id]) {
                     if(playerAnswers[id].validated) {
                         playerEl.classList.add('validated'); statusIcon = '<span class="status-icon">✔️</span>';
                     } else {
                         playerEl.classList.add('waiting'); statusIcon = '<span class="status-icon">💬</span>';
                     }
                 }
                 playerEl.innerHTML = `<span>${playerName}: ${playerScore}</span>${statusIcon}`;
                 scoresContainer.appendChild(playerEl);
            });
        }
        function endGame() {
            const finalRanking = document.getElementById('final-ranking');
            finalRanking.innerHTML = '';
            const sortedScores = Object.entries(scores).sort((a, b) => b[1] - a[1]);
            if (sortedScores.length === 0) { finalRanking.innerHTML = "<li>Aucun score n'a été enregistré.</li>"; return; }
            sortedScores.forEach(([playerId, score], index) => {
                const li = document.createElement('li');
                const trophy = index === 0 ? '🏆' : (index === 1 ? '🥈' : (index === 2 ? '🥉' : ''));
                const playerName = playerNames[playerId] || `Joueur ${parseInt(playerId) + 1}`;
                li.innerHTML = `<span>${trophy} ${playerName}</span> <strong>${score} points</strong>`;
                finalRanking.appendChild(li);
            });
        }
        function restartGame() {
            scores = {}; currentQuestionIndex = 0;
            switchScreen('game-screen');
            showQuestion();
        }
        function parseQuestions() {
            const input = document.getElementById('question-input').value.trim();
            if (!input) { questions = []; return; }
            const blocks = input.split('\n\n');
            questions = blocks.map(block => {
                const lines = block.split('\n').filter(line => line.trim() !== '');
                if (lines.length < 5) return null;
                const questionText = lines[0];
                const answers = lines.slice(1, 5);
                const correctAnswerIndex = answers.findIndex(answer => answer.endsWith('*'));
                if (correctAnswerIndex === -1) return null;
                const cleanedAnswers = answers.map(answer => answer.replace('*', '').trim());
                return { question: questionText, answers: cleanedAnswers, correct: correctAnswerIndex };
            }).filter(q => q !== null);
        }
    </script>
</body>
</html>
